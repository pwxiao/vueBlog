import{_ as e,c as l,a2 as a,o as d}from"./chunks/framework.BQmytedh.js";const f=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{"counter":true,"comment":true},"headers":[],"relativePath":"blog/zzexpression.md","filePath":"blog/zzexpression.md"}'),r={name:"blog/zzexpression.md"};function n(i,t,o,s,x,h){return d(),l("div",null,t[0]||(t[0]=[a(`<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h1><blockquote><p>正则表达式（Regular Expression）使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><div style="text-align:right;">———— 维基百科</div></blockquote><p>!!! abstract 正则表达式用途广泛，而且功能强大又好用。可以说既简单又繁琐，但是用起来很爽</p><pre><code>一些工具：

- [RegExr 正则在线测试工具](https://regexr.com/)
- [Regulex 正则表达式可视化](https://jex.im/regulex/)
- [HackerRank regex 习题集](https://www.hackerrank.com/domains/regex)
</code></pre><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h2><h3 id="普通字符" tabindex="-1">普通字符 <a class="header-anchor" href="#普通字符" aria-label="Permalink to &quot;普通字符&quot;">​</a></h3><p>所有不是元字符的字符都可以直接写出来用来匹配，比如大小写字母、数字、符号等</p><p>有语法意义的字符需要使用 \\ 转义，比如 \\( \\) \\[ \\] \\. 分别匹配 ()[]. 这五个字符</p><table tabindex="0"><thead><tr><th style="text-align:left;">语法</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">[...]</td><td style="text-align:left;">匹配任意在 <code>...</code> 中的字符，如 [ABC] 匹配所有 A B C 字符</td></tr><tr><td style="text-align:left;">[^...]</td><td style="text-align:left;">匹配任意不在 <code>...</code> 中的字符，如 [^ABC] 匹配除了 A B C 外的所有单个字符</td></tr><tr><td style="text-align:left;">[x-y]</td><td style="text-align:left;">按照顺序匹配从 <code>x</code> 到 <code>y</code> 到所有字符，如 [a-z] 匹配所有小写字母，[A-E] 匹配 A 到 E 这五个字符｜</td></tr><tr><td style="text-align:left;">.</td><td style="text-align:left;">匹配任意除了换行符以外的字符</td></tr><tr><td style="text-align:left;">\\w</td><td style="text-align:left;">匹配字母数字下划线，相当于 [a-zA-Z0-9_]</td></tr><tr><td style="text-align:left;">x|y</td><td style="text-align:left;">匹配 <code>x</code> 或 <code>y</code>，优先级最低，如 \`a</td></tr></tbody></table><h3 id="非打印字符" tabindex="-1">非打印字符 <a class="header-anchor" href="#非打印字符" aria-label="Permalink to &quot;非打印字符&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">语法</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">\\cx</td><td style="text-align:left;">匹配由 x 指明的控制字符，x 必须属于 [a-zA-Z]，否则 \\c 直接视为 c，如 \\cM 匹配 Ctrl-M 即回车符</td></tr><tr><td style="text-align:left;">\\f</td><td style="text-align:left;">匹配一个换页符，相当于 \\x0c \\cL</td></tr><tr><td style="text-align:left;">\\n</td><td style="text-align:left;">匹配一个换行符，相当于 \\x0a \\cJ</td></tr><tr><td style="text-align:left;">\\r</td><td style="text-align:left;">匹配一个回车符，相当于 \\x0d \\cM</td></tr><tr><td style="text-align:left;">\\t</td><td style="text-align:left;">匹配一个制表符，相当于 \\x09 \\cI</td></tr><tr><td style="text-align:left;">\\v</td><td style="text-align:left;">匹配一个垂直制表符，相当于 \\x0b \\cK</td></tr><tr><td style="text-align:left;">\\s</td><td style="text-align:left;">匹配任何空白字符，相当于 [ \\f\\n\\r\\t\\v]，unicode 下也会匹配全角空格符</td></tr><tr><td style="text-align:left;">\\S</td><td style="text-align:left;">匹配任何非空白符，相当于 [^ \\f\\n\\r\\t\\v]</td></tr></tbody></table><h3 id="限定符" tabindex="-1">限定符 <a class="header-anchor" href="#限定符" aria-label="Permalink to &quot;限定符&quot;">​</a></h3><p>用来指定一个子表达式出现了多少次</p><table tabindex="0"><thead><tr><th style="text-align:left;">语法</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">{n}</td><td style="text-align:left;">前一个子表达式匹配准确的 n 次，如 o{2} 匹配两个连续的 o</td></tr><tr><td style="text-align:left;">{n,}</td><td style="text-align:left;">前一个子表达式匹配至少 n 次，如 o{2,} 可以匹配 goooood 中的所有 o，但不匹配 god 中的 o</td></tr><tr><td style="text-align:left;">{n,m}</td><td style="text-align:left;">前一个子表达式匹配至少 n 次，至多 m 次</td></tr><tr><td style="text-align:left;">*</td><td style="text-align:left;">前一个子表达式匹配 0 次或多次，相当于 {0,}</td></tr><tr><td style="text-align:left;">+</td><td style="text-align:left;">前一个子表达式匹配 1 次或多次，相当于 {1,}</td></tr><tr><td style="text-align:left;">?</td><td style="text-align:left;">前一个子表达式可有可无（匹配 0 次或 1 次），相当于 {0,1}</td></tr></tbody></table><h4 id="贪婪" tabindex="-1">贪婪 <a class="header-anchor" href="#贪婪" aria-label="Permalink to &quot;贪婪&quot;">​</a></h4><p>* 和 + 的匹配都是贪婪的，即尽可能匹配更多的字符，而在它们后面加上 ? 就可以非贪婪（即最小匹配）</p><ul><li>&lt;.*&gt; 会匹配整个 <code>&lt;h1&gt;header&lt;/h1&gt;</code> 字符串</li><li>&lt;.*?&gt; 只会匹配其中的 <code>&lt;h1&gt;</code> 和 <code>&lt;/h1&gt;</code></li></ul><h3 id="定位符" tabindex="-1">定位符 <a class="header-anchor" href="#定位符" aria-label="Permalink to &quot;定位符&quot;">​</a></h3><p>只匹配位置，没有字符与之对应</p><table tabindex="0"><thead><tr><th style="text-align:left;">语法</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">^</td><td style="text-align:left;">匹配字符串开头，如果是多行模式，则新的一行也算新的字符串</td></tr><tr><td style="text-align:left;">$</td><td style="text-align:left;">匹配字符串结尾，多行模式同理看成多个字符串</td></tr><tr><td style="text-align:left;">\\b</td><td style="text-align:left;">匹配单词边界，即字符与空格中间的位置</td></tr><tr><td style="text-align:left;">\\B</td><td style="text-align:left;">匹配非单词边界</td></tr></tbody></table><p>定位符只能单独使用，不能附加限制符指定个数</p><h3 id="分组" tabindex="-1">分组 <a class="header-anchor" href="#分组" aria-label="Permalink to &quot;分组&quot;">​</a></h3><p>用 () 可以指定匹配一个组，使用 () 可以指定不同选项，每一项间用 | 分隔</p><p>同时 () 也是捕获分组，即括号内匹配的内容会被缓存，如果要避免这种，需要使用 (?😃 非捕获元来进行匹配</p><h4 id="反向引用" tabindex="-1">反向引用 <a class="header-anchor" href="#反向引用" aria-label="Permalink to &quot;反向引用&quot;">​</a></h4><p>被缓存的捕获分组可以直接使用 \\n 再次引用，其中 n 是 1 到 2 位的十进制数<br> 捕获分组的编号从 1 开始，最多 99 个，\\1 即表示和第一个圆括号中匹配的结果相同的部分</p><p>如 (abc|def)\\1 匹配 abcabc、defdef 但不匹配 abcdef、defabc</p><h4 id="先行断言和后行断言" tabindex="-1">先行断言和后行断言 <a class="header-anchor" href="#先行断言和后行断言" aria-label="Permalink to &quot;先行断言和后行断言&quot;">​</a></h4><p>正则表达式有先行断言（lookahead）和后行断言（lookbehind），分为四种形式：</p><table tabindex="0"><thead><tr><th style="text-align:center;">语法</th><th style="text-align:center;">名称</th></tr></thead><tbody><tr><td style="text-align:center;">(?=pattern)</td><td style="text-align:center;">零宽正向先行断言<br>zero-width positive lookahead assertion</td></tr><tr><td style="text-align:center;">(?!pattern)</td><td style="text-align:center;">零宽负向先行断言<br>zero-width negative lookahead assertion</td></tr><tr><td style="text-align:center;"><div style="font-variant-ligatures:none;">(?&lt;=pattern)</div></td><td style="text-align:center;">零宽正向后行断言<br>zero-width positive lookbehind assertion</td></tr><tr><td style="text-align:center;">(?&lt;!pattern)</td><td style="text-align:center;">零宽负向后行断言<br>zero-width negative lookbehind assertion</td></tr></tbody></table><p>和定位符类似，它只匹配位置，不匹配内容，所以叫做零宽（zero-width），这些位置的规则是：</p><ul><li>(?=pattern)：匹配后面可以匹配 pattern 的位置</li><li>(?!pattern)：匹配后面无法匹配 pattern 的位置</li><li><span style="font-variant-ligatures:none;">(?&lt;=pattern)</span>：匹配前面可以匹配 pattern 的位置</li><li>(?&lt;!pattern)：匹配前面无法匹配 pattern 的位置</li></ul><h2 id="修饰符" tabindex="-1">修饰符 <a class="header-anchor" href="#修饰符" aria-label="Permalink to &quot;修饰符&quot;">​</a></h2><p>修饰符不属于表达式的内容，但是指定了匹配的规则，js 中的正则写法为 /pattern/flags<br> 其中 flags 就是修饰符</p><table tabindex="0"><thead><tr><th style="text-align:left;">修饰符</th><th style="text-align:left;">名称</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;">i</td><td style="text-align:left;">ignore</td><td style="text-align:left;">忽略大小写</td></tr><tr><td style="text-align:left;">g</td><td style="text-align:left;">global</td><td style="text-align:left;">全局匹配，查找所有匹配项</td></tr><tr><td style="text-align:left;">m</td><td style="text-align:left;">multi-line</td><td style="text-align:left;">多行匹配，使 ^$ 匹配每行的开头和结尾</td></tr><tr><td style="text-align:left;">s</td><td style="text-align:left;">single-line</td><td style="text-align:left;">单行匹配，只视为一个字符串，. 也可以匹配换行符</td></tr></tbody></table><p>不同语言中写法和种类不同</p><h2 id="优先级" tabindex="-1">优先级 <a class="header-anchor" href="#优先级" aria-label="Permalink to &quot;优先级&quot;">​</a></h2><p>正则表达式也有优先级，同一优先级则从左向右运算，不同优先级则从高到低。从高到低：</p><ul><li>转义符 <code>\\</code></li><li>括号符 <code>(...) (?:...) (?=...) (?!...) (?&lt;=...) (?&lt;!...) [...] [^...]</code></li><li>限定符 <code>* + ? {n} {n,} {n,m}</code></li><li>定位符 <code>^ $</code></li><li>字符</li><li>或 <code>|</code></li></ul>`,39)]))}const c=e(r,[["render",n]]);export{f as __pageData,c as default};
